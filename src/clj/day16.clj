(ns clj.day16)

(def input "59781998462438675006185496762485925436970503472751174459080326994618036736403094024111488348676644802419244196591075975610084280308059415695059918368911890852851760032000543205724091764633390765212561307082338287866715489545069566330303873914343745198297391838950197434577938472242535458546669655890258618400619467693925185601880453581947475741536786956920286681271937042394272034410161080365044440682830248774547018223347551308590698989219880430394446893636437913072055636558787182933357009123440661477321673973877875974028654688639313502382365854245311641198762520478010015968789202270746880399268251176490599427469385384364675153461448007234636949")

(- (* 10000 (count input))
   5978199)

(quot 521801 650)
(- (* 803 650)
   521801)

; 149
(def part2-input (apply str (repeat 803 input)))

(def numbers (into [] (map #(- (int %) 48) part2-input)))

(defn abs-mod-10 [v] 
  (mod (Math/abs v) 10))

(defn cumsum [vec]
  (loop [n   0
         acc 0
         ret (transient [])]
    (if (= n (count vec))
      (persistent! ret)
      (let [v  (nth vec n)
            a' (+ acc v)]
        (recur (inc n)
               a'
               (conj! ret (abs-mod-10 a')))))))

(defn steps [n vec]
  (loop [i      0
         signal (into [] (reverse vec))]
    (println i)
    (if (= i n)
      (into [] (take 200 (reverse signal)))
      (recur (inc i) (cumsum signal)))))

(def ret (steps 100 numbers))
(drop 149 ret) ; 21130597
